{"ast":null,"code":"var _slicedToArray = require(\"/home/rudransh/public_html/MERN/react-node-ecommerce-front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _objectWithoutProperties = require(\"/home/rudransh/public_html/MERN/react-node-ecommerce-front/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar e = require(\"react\"),\n    t = require(\"clsx\");\n\nfunction n(e) {\n  return e && \"object\" == typeof e && \"default\" in e ? e : {\n    default: e\n  };\n}\n\nvar o =\n/*#__PURE__*/\nn(e),\n    s =\n/*#__PURE__*/\nn(t);\n\nconst a = e => \"number\" == typeof e && !isNaN(e),\n      r = e => \"string\" == typeof e,\n      i = e => \"function\" == typeof e,\n      l = e => r(e) || i(e) ? e : null,\n      c = t => e.isValidElement(t) || r(t) || i(t) || a(t);\n\nfunction u(e, t, n) {\n  void 0 === n && (n = 300);\n  const o = e.scrollHeight,\n        s = e.style;\n  requestAnimationFrame(() => {\n    s.minHeight = \"initial\", s.height = o + \"px\", s.transition = \"all \".concat(n, \"ms\"), requestAnimationFrame(() => {\n      s.height = \"0\", s.padding = \"0\", s.margin = \"0\", setTimeout(t, n);\n    });\n  });\n}\n\nfunction d(t) {\n  let n = t.enter,\n      s = t.exit,\n      _t$appendPosition = t.appendPosition,\n      a = _t$appendPosition === void 0 ? !1 : _t$appendPosition,\n      _t$collapse = t.collapse,\n      r = _t$collapse === void 0 ? !0 : _t$collapse,\n      _t$collapseDuration = t.collapseDuration,\n      i = _t$collapseDuration === void 0 ? 300 : _t$collapseDuration;\n  return function (t) {\n    let l = t.children,\n        c = t.position,\n        d = t.preventExitTransition,\n        f = t.done,\n        p = t.nodeRef,\n        m = t.isIn;\n    const g = a ? \"\".concat(n, \"--\").concat(c) : n,\n          h = a ? \"\".concat(s, \"--\").concat(c) : s,\n          y = e.useRef(0);\n    return e.useLayoutEffect(() => {\n      const e = p.current,\n            t = g.split(\" \"),\n            n = o => {\n        o.target === p.current && (e.dispatchEvent(new Event(\"d\")), e.removeEventListener(\"animationend\", n), e.removeEventListener(\"animationcancel\", n), 0 === y.current && \"animationcancel\" !== o.type && e.classList.remove(...t));\n      };\n\n      e.classList.add(...t), e.addEventListener(\"animationend\", n), e.addEventListener(\"animationcancel\", n);\n    }, []), e.useEffect(() => {\n      const e = p.current,\n            t = () => {\n        e.removeEventListener(\"animationend\", t), r ? u(e, f, i) : f();\n      };\n\n      m || (d ? t() : (y.current = 1, e.className += \" \".concat(h), e.addEventListener(\"animationend\", t)));\n    }, [m]), o.default.createElement(o.default.Fragment, null, l);\n  };\n}\n\nfunction f(e, t) {\n  return {\n    content: e.content,\n    containerId: e.props.containerId,\n    id: e.props.toastId,\n    theme: e.props.theme,\n    type: e.props.type,\n    data: e.props.data || {},\n    isLoading: e.props.isLoading,\n    icon: e.props.icon,\n    status: t\n  };\n}\n\nconst p = {\n  list: new Map(),\n  emitQueue: new Map(),\n\n  on(e, t) {\n    return this.list.has(e) || this.list.set(e, []), this.list.get(e).push(t), this;\n  },\n\n  off(e, t) {\n    if (t) {\n      const n = this.list.get(e).filter(e => e !== t);\n      return this.list.set(e, n), this;\n    }\n\n    return this.list.delete(e), this;\n  },\n\n  cancelEmit(e) {\n    const t = this.emitQueue.get(e);\n    return t && (t.forEach(clearTimeout), this.emitQueue.delete(e)), this;\n  },\n\n  emit(e) {\n    this.list.has(e) && this.list.get(e).forEach(t => {\n      const n = setTimeout(() => {\n        t(...[].slice.call(arguments, 1));\n      }, 0);\n      this.emitQueue.has(e) || this.emitQueue.set(e, []), this.emitQueue.get(e).push(n);\n    });\n  }\n\n},\n      m = e => {\n  let t = e.theme,\n      n = e.type,\n      s = _objectWithoutProperties(e, [\"theme\", \"type\"]);\n\n  return o.default.createElement(\"svg\", {\n    viewBox: \"0 0 24 24\",\n    width: \"100%\",\n    height: \"100%\",\n    fill: \"colored\" === t ? \"currentColor\" : \"var(--toastify-icon-color-\".concat(n, \")\"),\n    ...s\n  });\n},\n      g = {\n  info: function (e) {\n    return o.default.createElement(m, { ...e\n    }, o.default.createElement(\"path\", {\n      d: \"M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z\"\n    }));\n  },\n  warning: function (e) {\n    return o.default.createElement(m, { ...e\n    }, o.default.createElement(\"path\", {\n      d: \"M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z\"\n    }));\n  },\n  success: function (e) {\n    return o.default.createElement(m, { ...e\n    }, o.default.createElement(\"path\", {\n      d: \"M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z\"\n    }));\n  },\n  error: function (e) {\n    return o.default.createElement(m, { ...e\n    }, o.default.createElement(\"path\", {\n      d: \"M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z\"\n    }));\n  },\n  spinner: function () {\n    return o.default.createElement(\"div\", {\n      className: \"Toastify__spinner\"\n    });\n  }\n};\n\nfunction h(t) {\n  const _e$useReducer = e.useReducer(e => e + 1, 0),\n        _e$useReducer2 = _slicedToArray(_e$useReducer, 2),\n        n = _e$useReducer2[1],\n        _e$useState = e.useState([]),\n        _e$useState2 = _slicedToArray(_e$useState, 2),\n        o = _e$useState2[0],\n        s = _e$useState2[1],\n        u = e.useRef(null),\n        d = e.useRef(new Map()).current,\n        m = e => -1 !== o.indexOf(e),\n        h = e.useRef({\n    toastKey: 1,\n    displayedToast: 0,\n    count: 0,\n    queue: [],\n    props: t,\n    containerId: null,\n    isToastActive: m,\n    getToast: e => d.get(e)\n  }).current;\n\n  function y(e) {\n    let t = e.containerId;\n    const n = h.props.limit;\n    !n || t && h.containerId !== t || (h.count -= h.queue.length, h.queue = []);\n  }\n\n  function v(e) {\n    s(t => null == e ? [] : t.filter(t => t !== e));\n  }\n\n  function T() {\n    const _h$queue$shift = h.queue.shift(),\n          e = _h$queue$shift.toastContent,\n          t = _h$queue$shift.toastProps,\n          n = _h$queue$shift.staleId;\n\n    C(e, t, n);\n  }\n\n  function E(t, o) {\n    let s = o.delay,\n        m = o.staleId,\n        y = _objectWithoutProperties(o, [\"delay\", \"staleId\"]);\n\n    if (!c(t) || function (e) {\n      return !u.current || h.props.enableMultiContainer && e.containerId !== h.props.containerId || d.has(e.toastId) && null == e.updateId;\n    }(y)) return;\n\n    const E = y.toastId,\n          b = y.updateId,\n          I = y.data,\n          _ = h.props,\n          L = () => v(E),\n          O = null == b;\n\n    O && h.count++;\n    const N = { ..._,\n      style: _.toastStyle,\n      key: h.toastKey++,\n      ...Object.fromEntries(Object.entries(y).filter(e => {\n        let _e = _slicedToArray(e, 2),\n            t = _e[0],\n            n = _e[1];\n\n        return null != n;\n      })),\n      toastId: E,\n      updateId: b,\n      data: I,\n      closeToast: L,\n      isIn: !1,\n      className: l(y.className || _.toastClassName),\n      bodyClassName: l(y.bodyClassName || _.bodyClassName),\n      progressClassName: l(y.progressClassName || _.progressClassName),\n      autoClose: !y.isLoading && (x = y.autoClose, R = _.autoClose, !1 === x || a(x) && x > 0 ? x : R),\n\n      deleteToast() {\n        const e = f(d.get(E), \"removed\");\n        d.delete(E), p.emit(4, e);\n        const t = h.queue.length;\n\n        if (h.count = null == E ? h.count - h.displayedToast : h.count - 1, h.count < 0 && (h.count = 0), t > 0) {\n          const e = null == E ? h.props.limit : 1;\n          if (1 === t || 1 === e) h.displayedToast++, T();else {\n            const n = e > t ? t : e;\n            h.displayedToast = n;\n\n            for (let e = 0; e < n; e++) T();\n          }\n        } else n();\n      }\n\n    };\n    var x, R;\n    N.iconOut = function (t) {\n      let n = t.theme,\n          o = t.type,\n          s = t.isLoading,\n          l = t.icon,\n          c = null;\n      const u = {\n        theme: n,\n        type: o\n      };\n      return !1 === l || (i(l) ? c = l(u) : e.isValidElement(l) ? c = e.cloneElement(l, u) : r(l) || a(l) ? c = l : s ? c = g.spinner() : (e => e in g)(o) && (c = g[o](u))), c;\n    }(N), i(y.onOpen) && (N.onOpen = y.onOpen), i(y.onClose) && (N.onClose = y.onClose), N.closeButton = _.closeButton, !1 === y.closeButton || c(y.closeButton) ? N.closeButton = y.closeButton : !0 === y.closeButton && (N.closeButton = !c(_.closeButton) || _.closeButton);\n    let w = t;\n    e.isValidElement(t) && !r(t.type) ? w = e.cloneElement(t, {\n      closeToast: L,\n      toastProps: N,\n      data: I\n    }) : i(t) && (w = t({\n      closeToast: L,\n      toastProps: N,\n      data: I\n    })), _.limit && _.limit > 0 && h.count > _.limit && O ? h.queue.push({\n      toastContent: w,\n      toastProps: N,\n      staleId: m\n    }) : a(s) ? setTimeout(() => {\n      C(w, N, m);\n    }, s) : C(w, N, m);\n  }\n\n  function C(e, t, n) {\n    const o = t.toastId;\n    n && d.delete(n);\n    const a = {\n      content: e,\n      props: t\n    };\n    d.set(o, a), s(e => [...e, o].filter(e => e !== n)), p.emit(4, f(a, null == a.props.updateId ? \"added\" : \"updated\"));\n  }\n\n  return e.useEffect(() => (h.containerId = t.containerId, p.cancelEmit(3).on(0, E).on(1, e => u.current && v(e)).on(5, y).emit(2, h), () => {\n    d.clear(), p.emit(3, h);\n  }), []), e.useEffect(() => {\n    h.props = t, h.isToastActive = m, h.displayedToast = o.length;\n  }), {\n    getToastToRender: function (e) {\n      const n = new Map(),\n            o = Array.from(d.values());\n      return t.newestOnTop && o.reverse(), o.forEach(e => {\n        const t = e.props.position;\n        n.has(t) || n.set(t, []), n.get(t).push(e);\n      }), Array.from(n, t => e(t[0], t[1]));\n    },\n    containerRef: u,\n    isToastActive: m\n  };\n}\n\nfunction y(e) {\n  return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientX : e.clientX;\n}\n\nfunction v(e) {\n  return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientY : e.clientY;\n}\n\nfunction T(t) {\n  const _e$useState3 = e.useState(!1),\n        _e$useState4 = _slicedToArray(_e$useState3, 2),\n        n = _e$useState4[0],\n        o = _e$useState4[1],\n        _e$useState5 = e.useState(!1),\n        _e$useState6 = _slicedToArray(_e$useState5, 2),\n        s = _e$useState6[0],\n        a = _e$useState6[1],\n        r = e.useRef(null),\n        l = e.useRef({\n    start: 0,\n    x: 0,\n    y: 0,\n    delta: 0,\n    removalDistance: 0,\n    canCloseOnClick: !0,\n    canDrag: !1,\n    boundingRect: null,\n    didMove: !1\n  }).current,\n        c = e.useRef(t),\n        u = t.autoClose,\n        d = t.pauseOnHover,\n        f = t.closeToast,\n        p = t.onClick,\n        m = t.closeOnClick;\n\n  function g(e) {\n    if (t.draggable) {\n      \"touchstart\" === e.nativeEvent.type && e.nativeEvent.preventDefault(), l.didMove = !1, document.addEventListener(\"mousemove\", C), document.addEventListener(\"mouseup\", b), document.addEventListener(\"touchmove\", C), document.addEventListener(\"touchend\", b);\n      const n = r.current;\n      l.canCloseOnClick = !0, l.canDrag = !0, l.boundingRect = n.getBoundingClientRect(), n.style.transition = \"\", l.x = y(e.nativeEvent), l.y = v(e.nativeEvent), \"x\" === t.draggableDirection ? (l.start = l.x, l.removalDistance = n.offsetWidth * (t.draggablePercent / 100)) : (l.start = l.y, l.removalDistance = n.offsetHeight * (80 === t.draggablePercent ? 1.5 * t.draggablePercent : t.draggablePercent / 100));\n    }\n  }\n\n  function h(e) {\n    if (l.boundingRect) {\n      const _l$boundingRect = l.boundingRect,\n            n = _l$boundingRect.top,\n            o = _l$boundingRect.bottom,\n            s = _l$boundingRect.left,\n            a = _l$boundingRect.right;\n      \"touchend\" !== e.nativeEvent.type && t.pauseOnHover && l.x >= s && l.x <= a && l.y >= n && l.y <= o ? E() : T();\n    }\n  }\n\n  function T() {\n    o(!0);\n  }\n\n  function E() {\n    o(!1);\n  }\n\n  function C(e) {\n    const o = r.current;\n    l.canDrag && o && (l.didMove = !0, n && E(), l.x = y(e), l.y = v(e), l.delta = \"x\" === t.draggableDirection ? l.x - l.start : l.y - l.start, l.start !== l.x && (l.canCloseOnClick = !1), o.style.transform = \"translate\".concat(t.draggableDirection, \"(\").concat(l.delta, \"px)\"), o.style.opacity = \"\" + (1 - Math.abs(l.delta / l.removalDistance)));\n  }\n\n  function b() {\n    document.removeEventListener(\"mousemove\", C), document.removeEventListener(\"mouseup\", b), document.removeEventListener(\"touchmove\", C), document.removeEventListener(\"touchend\", b);\n    const e = r.current;\n\n    if (l.canDrag && l.didMove && e) {\n      if (l.canDrag = !1, Math.abs(l.delta) > l.removalDistance) return a(!0), void t.closeToast();\n      e.style.transition = \"transform 0.2s, opacity 0.2s\", e.style.transform = \"translate\".concat(t.draggableDirection, \"(0)\"), e.style.opacity = \"1\";\n    }\n  }\n\n  e.useEffect(() => {\n    c.current = t;\n  }), e.useEffect(() => (r.current && r.current.addEventListener(\"d\", T, {\n    once: !0\n  }), i(t.onOpen) && t.onOpen(e.isValidElement(t.children) && t.children.props), () => {\n    const t = c.current;\n    i(t.onClose) && t.onClose(e.isValidElement(t.children) && t.children.props);\n  }), []), e.useEffect(() => (t.pauseOnFocusLoss && (document.hasFocus() || E(), window.addEventListener(\"focus\", T), window.addEventListener(\"blur\", E)), () => {\n    t.pauseOnFocusLoss && (window.removeEventListener(\"focus\", T), window.removeEventListener(\"blur\", E));\n  }), [t.pauseOnFocusLoss]);\n  const I = {\n    onMouseDown: g,\n    onTouchStart: g,\n    onMouseUp: h,\n    onTouchEnd: h\n  };\n  return u && d && (I.onMouseEnter = E, I.onMouseLeave = T), m && (I.onClick = e => {\n    p && p(e), l.canCloseOnClick && f();\n  }), {\n    playToast: T,\n    pauseToast: E,\n    isRunning: n,\n    preventExitTransition: s,\n    toastRef: r,\n    eventHandlers: I\n  };\n}\n\nfunction E(e) {\n  let t = e.closeToast,\n      n = e.theme,\n      _e$ariaLabel = e.ariaLabel,\n      s = _e$ariaLabel === void 0 ? \"close\" : _e$ariaLabel;\n  return o.default.createElement(\"button\", {\n    className: \"Toastify__close-button Toastify__close-button--\".concat(n),\n    type: \"button\",\n    onClick: e => {\n      e.stopPropagation(), t(e);\n    },\n    \"aria-label\": s\n  }, o.default.createElement(\"svg\", {\n    \"aria-hidden\": \"true\",\n    viewBox: \"0 0 14 16\"\n  }, o.default.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z\"\n  })));\n}\n\nfunction C(e) {\n  let t = e.delay,\n      n = e.isRunning,\n      a = e.closeToast,\n      _e$type = e.type,\n      r = _e$type === void 0 ? \"default\" : _e$type,\n      l = e.hide,\n      c = e.className,\n      u = e.style,\n      d = e.controlledProgress,\n      f = e.progress,\n      p = e.rtl,\n      m = e.isIn,\n      g = e.theme;\n  const h = l || d && 0 === f,\n        y = { ...u,\n    animationDuration: \"\".concat(t, \"ms\"),\n    animationPlayState: n ? \"running\" : \"paused\",\n    opacity: h ? 0 : 1\n  };\n  d && (y.transform = \"scaleX(\".concat(f, \")\"));\n  const v = s.default(\"Toastify__progress-bar\", d ? \"Toastify__progress-bar--controlled\" : \"Toastify__progress-bar--animated\", \"Toastify__progress-bar-theme--\".concat(g), \"Toastify__progress-bar--\".concat(r), {\n    \"Toastify__progress-bar--rtl\": p\n  }),\n        T = i(c) ? c({\n    rtl: p,\n    type: r,\n    defaultClassName: v\n  }) : s.default(v, c);\n  return o.default.createElement(\"div\", {\n    role: \"progressbar\",\n    \"aria-hidden\": h ? \"true\" : \"false\",\n    \"aria-label\": \"notification timer\",\n    className: T,\n    style: y,\n    [d && f >= 1 ? \"onTransitionEnd\" : \"onAnimationEnd\"]: d && f < 1 ? null : () => {\n      m && a();\n    }\n  });\n}\n\nconst b = t => {\n  const _T = T(t),\n        n = _T.isRunning,\n        a = _T.preventExitTransition,\n        r = _T.toastRef,\n        l = _T.eventHandlers,\n        c = t.closeButton,\n        u = t.children,\n        d = t.autoClose,\n        f = t.onClick,\n        p = t.type,\n        m = t.hideProgressBar,\n        g = t.closeToast,\n        h = t.transition,\n        y = t.position,\n        v = t.className,\n        b = t.style,\n        I = t.bodyClassName,\n        _ = t.bodyStyle,\n        L = t.progressClassName,\n        O = t.progressStyle,\n        N = t.updateId,\n        x = t.role,\n        R = t.progress,\n        w = t.rtl,\n        M = t.toastId,\n        $ = t.deleteToast,\n        k = t.isIn,\n        B = t.isLoading,\n        P = t.iconOut,\n        D = t.closeOnClick,\n        A = t.theme,\n        z = s.default(\"Toastify__toast\", \"Toastify__toast-theme--\".concat(A), \"Toastify__toast--\".concat(p), {\n    \"Toastify__toast--rtl\": w\n  }, {\n    \"Toastify__toast--close-on-click\": D\n  }),\n        F = i(v) ? v({\n    rtl: w,\n    position: y,\n    type: p,\n    defaultClassName: z\n  }) : s.default(z, v),\n        S = !!R || !d,\n        q = {\n    closeToast: g,\n    type: p,\n    theme: A\n  };\n\n  let H = null;\n  return !1 === c || (H = i(c) ? c(q) : e.isValidElement(c) ? e.cloneElement(c, q) : E(q)), o.default.createElement(h, {\n    isIn: k,\n    done: $,\n    position: y,\n    preventExitTransition: a,\n    nodeRef: r\n  }, o.default.createElement(\"div\", {\n    id: M,\n    onClick: f,\n    className: F,\n    ...l,\n    style: b,\n    ref: r\n  }, o.default.createElement(\"div\", { ...(k && {\n      role: x\n    }),\n    className: i(I) ? I({\n      type: p\n    }) : s.default(\"Toastify__toast-body\", I),\n    style: _\n  }, null != P && o.default.createElement(\"div\", {\n    className: s.default(\"Toastify__toast-icon\", {\n      \"Toastify--animate-icon Toastify__zoom-enter\": !B\n    })\n  }, P), o.default.createElement(\"div\", null, u)), H, o.default.createElement(C, { ...(N && !S ? {\n      key: \"pb-\".concat(N)\n    } : {}),\n    rtl: w,\n    theme: A,\n    delay: d,\n    isRunning: n,\n    isIn: k,\n    closeToast: g,\n    hide: m,\n    type: p,\n    style: O,\n    className: L,\n    controlledProgress: S,\n    progress: R || 0\n  })));\n},\n      I = function (e, t) {\n  return void 0 === t && (t = !1), {\n    enter: \"Toastify--animate Toastify__\".concat(e, \"-enter\"),\n    exit: \"Toastify--animate Toastify__\".concat(e, \"-exit\"),\n    appendPosition: t\n  };\n},\n      _ = d(I(\"bounce\", !0)),\n      L = d(I(\"slide\", !0)),\n      O = d(I(\"zoom\")),\n      N = d(I(\"flip\")),\n      x = e.forwardRef((t, n) => {\n  const _h = h(t),\n        a = _h.getToastToRender,\n        r = _h.containerRef,\n        c = _h.isToastActive,\n        u = t.className,\n        d = t.style,\n        f = t.rtl,\n        p = t.containerId;\n\n  function m(e) {\n    const t = s.default(\"Toastify__toast-container\", \"Toastify__toast-container--\".concat(e), {\n      \"Toastify__toast-container--rtl\": f\n    });\n    return i(u) ? u({\n      position: e,\n      rtl: f,\n      defaultClassName: t\n    }) : s.default(t, l(u));\n  }\n\n  return e.useEffect(() => {\n    n && (n.current = r.current);\n  }, []), o.default.createElement(\"div\", {\n    ref: r,\n    className: \"Toastify\",\n    id: p\n  }, a((e, t) => {\n    const n = t.length ? { ...d\n    } : { ...d,\n      pointerEvents: \"none\"\n    };\n    return o.default.createElement(\"div\", {\n      className: m(e),\n      style: n,\n      key: \"container-\".concat(e)\n    }, t.map((e, n) => {\n      let s = e.content,\n          a = e.props;\n      return o.default.createElement(b, { ...a,\n        isIn: c(a.toastId),\n        style: { ...a.style,\n          \"--nth\": n + 1,\n          \"--len\": t.length\n        },\n        key: \"toast-\".concat(a.key)\n      }, s);\n    }));\n  }));\n});\n\nx.displayName = \"ToastContainer\", x.defaultProps = {\n  position: \"top-right\",\n  transition: _,\n  autoClose: 5e3,\n  closeButton: E,\n  pauseOnHover: !0,\n  pauseOnFocusLoss: !0,\n  closeOnClick: !0,\n  draggable: !0,\n  draggablePercent: 80,\n  draggableDirection: \"x\",\n  role: \"alert\",\n  theme: \"light\"\n};\nlet R,\n    w = new Map(),\n    M = [],\n    $ = 1;\n\nfunction k() {\n  return \"\" + $++;\n}\n\nfunction B(e) {\n  return e && (r(e.toastId) || a(e.toastId)) ? e.toastId : k();\n}\n\nfunction P(e, t) {\n  return w.size > 0 ? p.emit(0, e, t) : M.push({\n    content: e,\n    options: t\n  }), t.toastId;\n}\n\nfunction D(e, t) {\n  return { ...t,\n    type: t && t.type || e,\n    toastId: B(t)\n  };\n}\n\nfunction A(e) {\n  return (t, n) => P(t, D(e, n));\n}\n\nfunction z(e, t) {\n  return P(e, D(\"default\", t));\n}\n\nz.loading = (e, t) => P(e, D(\"default\", {\n  isLoading: !0,\n  autoClose: !1,\n  closeOnClick: !1,\n  closeButton: !1,\n  draggable: !1,\n  ...t\n})), z.promise = function (e, t, n) {\n  let o,\n      s = t.pending,\n      a = t.error,\n      l = t.success;\n  s && (o = r(s) ? z.loading(s, n) : z.loading(s.render, { ...n,\n    ...s\n  }));\n\n  const c = {\n    isLoading: null,\n    autoClose: null,\n    closeOnClick: null,\n    closeButton: null,\n    draggable: null\n  },\n        u = (e, t, s) => {\n    if (null == t) return void z.dismiss(o);\n    const a = {\n      type: e,\n      ...c,\n      ...n,\n      data: s\n    },\n          i = r(t) ? {\n      render: t\n    } : t;\n    return o ? z.update(o, { ...a,\n      ...i\n    }) : z(i.render, { ...a,\n      ...i\n    }), s;\n  },\n        d = i(e) ? e() : e;\n\n  return d.then(e => u(\"success\", l, e)).catch(e => u(\"error\", a, e)), d;\n}, z.success = A(\"success\"), z.info = A(\"info\"), z.error = A(\"error\"), z.warning = A(\"warning\"), z.warn = z.warning, z.dark = (e, t) => P(e, D(\"default\", {\n  theme: \"dark\",\n  ...t\n})), z.dismiss = e => {\n  w.size > 0 ? p.emit(1, e) : M = M.filter(t => null != e && t.options.toastId !== e);\n}, z.clearWaitingQueue = function (e) {\n  return void 0 === e && (e = {}), p.emit(5, e);\n}, z.isActive = e => {\n  let t = !1;\n  return w.forEach(n => {\n    n.isToastActive && n.isToastActive(e) && (t = !0);\n  }), t;\n}, z.update = function (e, t) {\n  void 0 === t && (t = {}), setTimeout(() => {\n    const n = function (e, t) {\n      let n = t.containerId;\n      const o = w.get(n || R);\n      return o && o.getToast(e);\n    }(e, t);\n\n    if (n) {\n      const o = n.props,\n            s = n.content,\n            a = {\n        delay: 100,\n        ...o,\n        ...t,\n        toastId: t.toastId || e,\n        updateId: k()\n      };\n      a.toastId !== e && (a.staleId = e);\n      const r = a.render || s;\n      delete a.render, P(r, a);\n    }\n  }, 0);\n}, z.done = e => {\n  z.update(e, {\n    progress: 1\n  });\n}, z.onChange = e => (p.on(4, e), () => {\n  p.off(4, e);\n}), z.POSITION = {\n  TOP_LEFT: \"top-left\",\n  TOP_RIGHT: \"top-right\",\n  TOP_CENTER: \"top-center\",\n  BOTTOM_LEFT: \"bottom-left\",\n  BOTTOM_RIGHT: \"bottom-right\",\n  BOTTOM_CENTER: \"bottom-center\"\n}, z.TYPE = {\n  INFO: \"info\",\n  SUCCESS: \"success\",\n  WARNING: \"warning\",\n  ERROR: \"error\",\n  DEFAULT: \"default\"\n}, p.on(2, e => {\n  R = e.containerId || e, w.set(R, e), M.forEach(e => {\n    p.emit(0, e.content, e.options);\n  }), M = [];\n}).on(3, e => {\n  w.delete(e.containerId || e), 0 === w.size && p.off(0).off(1).off(5);\n}), exports.Bounce = _, exports.Flip = N, exports.Icons = g, exports.Slide = L, exports.ToastContainer = x, exports.Zoom = O, exports.collapseToast = u, exports.cssTransition = d, exports.toast = z, exports.useToast = T, exports.useToastContainer = h;","map":null,"metadata":{},"sourceType":"script"}